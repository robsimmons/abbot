open! Core
open Abbot

let main ~input_file ~output_file ~language_specific ~max_line_length () =
  let parse_tree =
    In_channel.with_file input_file ~f:(fun in_channel ->
      let lexbuf = Lexing.from_channel in_channel in
      lexbuf.lex_curr_p <- { lexbuf.lex_curr_p with pos_fname = input_file };
      Parser.all_defns Lexer.token lexbuf)
  in
  let typed = Type_checker.check_defns parse_tree in
  let output_file =
    match output_file with
    | Some output_file -> output_file
    | None ->
      match String.rsplit2 input_file ~on:'.' with
      | None -> input_file
      | Some (input_file_base, _) -> input_file_base
  in
  let (output_interface_ast, output_implementation_ast) =
    match language_specific with
    | `Ocaml -> Ocaml_ast_gen.gen_ast ~module_name:(String.capitalize output_file) typed
    | `Sml_with_structure_name structure_name -> Sml_ast_gen.gen_ast ~structure_name typed
  in
  let output_language =
    match language_specific with
    | `Ocaml -> `Ocaml
    | `Sml_with_structure_name _ -> `Sml
  in
  let output_interface_file =
    match output_language with
    | `Ocaml -> output_file ^ "_intf.ml"
    | `Sml -> output_file ^ ".sig"
  in
  let output_implementation_file =
    match output_language with
    | `Ocaml -> output_file ^ ".ml"
    | `Sml -> output_file ^ ".sml"
  in
  let output_mli_file =
    match output_language with
    | `Sml -> None
    | `Ocaml -> Some (output_file ^ ".mli")
  in
  begin
    match
      String.equal input_file output_interface_file
      || String.equal input_file output_implementation_file
      || Option.equal String.equal (Some input_file) output_mli_file
    with
    | false -> ()
    | true ->
      raise_s
        [%message
          "Input file matches one of the output files. Quitting to avoid overwriting it."
            (input_file : string)
            (output_interface_file : string)
            (output_implementation_file : string)]
  end;
  Out_channel.with_file output_interface_file ~f:(fun out_channel ->
    Ast_layout.layout_structure output_language output_interface_ast
    |> Layout.to_string ~max_line_length
    |> Out_channel.output_string out_channel);
  Out_channel.with_file output_implementation_file ~f:(fun out_channel ->
    Ast_layout.layout_structure output_language output_implementation_ast
    |> Layout.to_string ~max_line_length
    |> Out_channel.output_string out_channel);
  match output_mli_file with
  | None -> ()
  | Some output_mli_file ->
    Out_channel.with_file output_mli_file ~f:(fun out_channel ->
      let module_name = String.capitalize output_file in
      Out_channel.output_string out_channel
        (sprintf "include %s_intf.%s" module_name module_name))
;;

open Command.Let_syntax

let command language_specific_param =
  [%map_open
    let input_file =
      anon ("ABBOT_FILE" %: string)
    and output_file =
      flag "-output-file" (optional string)
        ~doc:" base name of output files (defaults to input with the file extension dropped)"
    and language_specific = language_specific_param
    and max_line_length =
      flag "-max-line-length" (optional_with_default 80 int)
        ~doc:" (default 80) the desired maximum length of lines in the generated code."
    in
    main
      ~input_file
      ~output_file
      ~language_specific:(language_specific ~input_file ~output_file)
      ~max_line_length
  ]
;;

let ocaml_command =
  Command.basic
    ~summary:"Generate ocaml code fore abstract binding trees."
    (command (return (fun ~input_file:_ ~output_file:_ -> `Ocaml)))
;;

let sml_command =
  Command.basic
    ~summary:"Generate sml code for abstract binding trees."
    (command
       [%map_open
         let structure_name =
           flag "-structure-name" (optional string)
             ~doc:" name to use for the structure and corresponding signature generated by abbot."
         in
         (fun ~input_file ~output_file ->
            let file_name_without_extensions file_name =
              match String.lsplit2 ~on:'.' file_name with
              | None -> file_name
              | Some (file_name, _extensions) -> file_name
            in
            let structure_name =
              match structure_name with
              | Some structure_name -> structure_name
              | None ->
                match output_file with
                | Some output_file -> file_name_without_extensions output_file
                | None -> file_name_without_extensions input_file
            in
            `Sml_with_structure_name structure_name)
       ])
;;

let () =
  Command_unix.run
    (Command.group
       ~summary:"Generate abstract binding trees a simple specification language."
       [ ("ocaml", ocaml_command)
       ; ("sml", sml_command)
       ])
;;
